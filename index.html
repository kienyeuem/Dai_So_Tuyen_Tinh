<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê·∫°i S·ªë Tuy·∫øn T√≠nh - Ki√™n So Sad</title>
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            --bg-gradient: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --border-color: rgba(148, 163, 184, 0.1);
            --input-bg: rgba(15, 23, 42, 0.6);
            --highlight-bg: rgba(59, 130, 246, 0.2);
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-main);
            max-width: 95%;
            padding: 100px 20px 40px;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        /* Background effect */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('https://images.unsplash.com/photo-1635070041078-e363dbe005cb?q=80&w=2070&auto=format&fit=crop');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.15;
            filter: blur(2px);
            pointer-events: none;
            z-index: -1;
            transition: opacity 0.3s;
        }

        h1 { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 30px;
            margin: 0;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            z-index: 1000;
            font-size: 1.8rem;
            text-align: left;
            color: white;
        }
        
        h2 { color: var(--text-main); margin-top: 0; }

        .controls {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            margin-bottom: 24px;
            text-align: center;
            transition: transform 0.2s;
        }

        input[type="text"], input[type="number"] {
            padding: 10px 15px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-main);
            width: 60px;
            text-align: center;
            font-size: 1rem;
            transition: all 0.2s;
        }

        input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        button {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 5px;
        }

        button:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            filter: brightness(1.1);
        }

        /* ·∫®n n√∫t tƒÉng gi·∫£m (spinners) trong √¥ nh·∫≠p s·ªë */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Matrix Input Grid */
        #matrix-input-area {
            display: grid;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .matrix-row { display: flex; gap: 10px; }
        .matrix-cell { width: 60px; }

        /* Steps Display */
        .step-container {
            background: var(--card-bg);
            margin-bottom: 20px;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid #3b82f6;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            color: var(--text-main);
        }

        .step-description {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #60a5fa;
        }

        .matrix-display {
            font-family: 'Courier New', Courier, monospace;
            display: inline-block;
            position: relative;
            padding: 0 10px;
        }

        .matrix-display::before, .matrix-display::after {
            content: "";
            position: absolute;
            top: 0; bottom: 0;
            width: 6px;
            border: 2px solid var(--text-main);
        }
        .matrix-display::before { left: 0; border-right: none; }
        .matrix-display::after { right: 0; border-left: none; }

        table { border-collapse: collapse; margin: 0 auto; }
        td { padding: 8px 12px; text-align: right; font-size: 1.1em; }
        
        .highlight { background-color: var(--highlight-bg); color: #60a5fa; font-weight: bold; border-radius: 4px; }
        .separator { border-left: 2px solid var(--text-muted); }

        /* Button Grid for Actions */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .file-upload-btn {
            background: linear-gradient(135deg, #475569, #334155);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 5px;
            display: inline-block;
        }

        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            filter: brightness(1.1);
        }

        .export-buttons {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        @media print {
            body { background: white !important; color: black !important; }
            body::before { display: none; }
            .controls { display: none !important; }
            h1, .action-buttons, .export-buttons { display: none !important; }
            .step-container { background: white !important; color: black !important; border: 1px solid #ccc; box-shadow: none; break-inside: avoid; }
            .step-description { color: #000 !important; }
            .highlight { background-color: #eee !important; color: #000 !important; }
            .matrix-display::before, .matrix-display::after { border-color: #000 !important; }
            .separator { border-color: #000 !important; }
            #solution-steps { display: block !important; }
        }

        /* Menu Styles */
        #main-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 10px 0;
        }

        .menu-card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            padding: 30px 20px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 160px;
            position: relative;
            overflow: hidden;
        }

        .menu-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .menu-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3), 0 0 20px rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
            background: rgba(30, 41, 59, 0.85);
        }

        .menu-card:hover::after {
            opacity: 1;
        }

        .menu-card h3 {
            margin: 15px 0 0;
            color: var(--text-main);
            font-size: 1.2rem;
            transition: color 0.3s;
            z-index: 1;
        }

        .menu-card:hover h3 {
            color: #60a5fa;
        }

        .menu-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            transition: transform 0.3s ease;
            z-index: 1;
        }

        .menu-card:hover .menu-icon {
            transform: scale(1.1) rotate(5deg);
        }

        /* Calculator View Header */
        .calc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            background: var(--card-bg);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .calc-header h2 { margin: 0; font-size: 1.5rem; }

        .back-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            padding: 8px 16px;
            box-shadow: none;
            margin: 0;
        }
        
        .back-btn:hover {
            background: var(--highlight-bg);
            transform: none;
        }

        #dimension-inputs input {
            width: 45px;
        }

        /* History Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .modal-header h2 { margin: 0; color: var(--text-main); }

        .modal-header .close-btn { background: none; border: none; font-size: 2rem; color: var(--text-muted); cursor: pointer; padding: 0; margin: 0; line-height: 1; box-shadow: none; }

        .modal-body { overflow-y: auto; }

        #history-list { list-style: none; padding: 0; margin: 0; }

        #history-list li { background: var(--input-bg); padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border: 1px solid var(--border-color); }

        #history-list .history-info { flex-grow: 1; }

        #history-list .history-type { font-weight: 600; color: var(--text-main); }

        #history-list .history-time { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }

        #history-list .history-actions button { padding: 6px 12px; font-size: 0.9rem; margin-left: 8px; }


        /* Matrix Wrapper Styles */
        .matrix-wrapper {
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 25px 15px 15px;
            margin: 10px;
            position: relative;
            background: rgba(255, 255, 255, 0.02);
            display: inline-block;
            vertical-align: top;
            width: 100%;
        }
        .matrix-label {
            position: absolute;
            top: -12px;
            left: 15px;
            background: var(--card-bg);
            padding: 0 10px;
            font-weight: bold;
            color: #60a5fa;
            font-size: 0.9rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            h1 {
                position: static;
                font-size: 1.5rem;
                padding: 20px;
                text-align: center;
            }
            body {
                padding: 0 10px 40px;
            }
            .controls {
                padding: 20px 15px;
            }
            .matrix-cell {
                flex: 1; /* Distribute space equally */
                min-width: 40px; /* Prevent cells from being too tiny */
                width: auto; /* Override desktop fixed width */
                font-size: 16px; /* Prevent zoom on iOS */
            }
            #matrix-input-area {
                display: block;
                text-align: center;
            }
            .matrix-wrapper {
                display: inline-block;
                width: 100%;
                max-width: 100%;
                margin-bottom: 20px;
                vertical-align: top;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>

    <h1>ƒê·∫°i S·ªë Tuy·∫øn T√≠nh</h1>
    
    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-card" onclick="selectMode('inverse-gauss')">
            <div class="menu-icon"></div>
            <h3>Ngh·ªãch ƒê·∫£o (Gauss)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('inverse-adj')">
            <div class="menu-icon"></div>
            <h3>T√≠nh ma tr·∫≠n ngh·ªãch ƒë·∫£o</h3>
        </div>
        <div class="menu-card" onclick="selectMode('determinant')">
            <div class="menu-icon"></div>
            <h3>ƒê·ªãnh Th·ª©c (Det)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('determinant-laplace')">
            <div class="menu-icon"></div>
            <h3>ƒê·ªãnh Th·ª©c (Laplace)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('determinant-geo')">
            <div class="menu-icon"></div>
            <h3>ƒê·ªãnh Th·ª©c (H√¨nh H·ªçc)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('rank')">
            <div class="menu-icon"></div>
            <h3>H·∫°ng Ma Tr·∫≠n (Rank)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('linear-system')">
            <div class="menu-icon">x=</div>
            <h3>Gi·∫£i H·ªá PT (Ax=B)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('eigen')">
            <div class="menu-icon"></div>
            <h3>Gi√° Tr·ªã Ri√™ng</h3>
        </div>
        <div class="menu-card" onclick="selectMode('multiplication')">
            <div class="menu-icon"></div>
            <h3>Nh√¢n Ma Tr·∫≠n (AxB)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('power')">
            <div class="menu-icon"></div>
            <h3>L≈©y Th·ª´a (A^k)</h3>
        </div>
        <div class="menu-card" onclick="selectMode('laplace')">
            <div class="menu-icon">‚à´</div>
            <h3>Bi·∫øn ƒë·ªïi Laplace</h3>
        </div>
        <div class="menu-card" onclick="selectMode('inverse-laplace')">
            <div class="menu-icon">‚Ü©</div>
            <h3>Laplace Ng∆∞·ª£c</h3>
        </div>
    </div>

    <!-- Calculator View (Hidden by default) -->
    <div id="calculator-view" style="display: none;">
        <div class="calc-header">
            <button class="back-btn" onclick="goToHome()">‚¨Ö Quay l·∫°i</button>
            <h2 id="feature-title">T√≠nh To√°n</h2>
            <div style="width: 80px;"></div> <!-- Spacer for centering -->
        </div>

        <div class="controls" id="matrix-controls">
            <div id="dimension-inputs" style="display: inline-block;"></div>
            <button onclick="generateInputs()">T·∫°o L∆∞·ªõi</button>
            <label for="csv-input" class="file-upload-btn">üìÇ T·∫£i l√™n CSV</label>
            <input type="file" id="csv-input" accept=".csv" style="display: none;">
        </div>

        <!-- Laplace Controls -->
        <div class="controls" id="laplace-controls" style="display:none;">
            <div style="margin-bottom: 15px;">
                <label id="laplace-label" style="font-size: 1.1rem; font-weight: 600;">Ch·ªçn h√†m f(t): </label>
                <select id="laplace-func-type" onchange="updateLaplaceInputs()" style="padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-main); font-size: 1rem;">
                    <option value="const">H·∫±ng s·ªë (C)</option>
                    <option value="poly">ƒêa th·ª©c (t^n)</option>
                    <option value="exp">M≈© (e^at)</option>
                    <option value="sin">Sin (sin kt)</option>
                    <option value="cos">Cos (cos kt)</option>
                    <option value="exp_sin">e^at * sin(kt)</option>
                    <option value="exp_cos">e^at * cos(kt)</option>
                </select>
            </div>
            <div id="laplace-inputs" style="display:flex; gap:15px; justify-content:center; align-items:center; margin-bottom: 20px; flex-wrap: wrap;">
                <!-- Dynamic inputs -->
            </div>
            <button id="laplace-btn" onclick="calculateLaplaceTransform()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">Bi·∫øn ƒë·ªïi sang F(s)</button>
        </div>

        <div class="controls" id="input-container" style="display:none;">
            <div id="matrix-input-area"></div>
            <div id="action-area" style="margin-top: 20px;"></div>
        </div>

        <div id="solution-steps"></div>

        <div class="export-buttons">
            <button onclick="openHistoryModal()" style="background: linear-gradient(135deg, #475569, #334155)">üìú L·ªãch s·ª≠</button>
            <button onclick="exportToImage()" style="background: linear-gradient(135deg, #475569, #334155)">üì∏ L∆∞u ·∫¢nh</button>
            <button onclick="window.print()" style="background: linear-gradient(135deg, #475569, #334155)">üñ®Ô∏è In / L∆∞u PDF</button>
        </div>
    </div>

    <!-- History Modal HTML -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>L·ªãch s·ª≠ c√°c b√†i to√°n</h2>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button onclick="clearAllHistory()" style="background: #ef4444; padding: 6px 12px; font-size: 0.9rem;">X√≥a t·∫•t c·∫£</button>
                    <button class="close-btn" onclick="closeHistoryModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <ul id="history-list"></ul>
            </div>
        </div>
    </div>

<script>
    /**
     * Class x·ª≠ l√Ω ph√¢n s·ªë ƒë·ªÉ t√≠nh to√°n ch√≠nh x√°c
     */
    class Fraction {
        static gcd(a, b) { return b === 0 ? a : Fraction.gcd(b, a % b); }

        constructor(numerator = 0, denominator = 1) {
            if (denominator === 0) throw new Error("M·∫´u s·ªë kh√¥ng th·ªÉ b·∫±ng 0");
            if (denominator < 0) { numerator = -numerator; denominator = -denominator; }
            this.num = numerator;
            this.den = denominator;
            this.simplify();
        }

        simplify() {
            if (this.num === 0) { this.den = 1; return; }
            const common = Fraction.gcd(Math.abs(this.num), this.den);
            this.num /= common;
            this.den /= common;
        }

        static fromString(str) {
            if (typeof str !== 'string') str = String(str);
            if (str.includes('/')) {
                const parts = str.split('/');
                return new Fraction(parseInt(parts[0]), parseInt(parts[1]));
            }
            const num = parseInt(str);
            return new Fraction(isNaN(num) ? 0 : num, 1);
        }

        toString() { return this.den === 1 ? `${this.num}` : `${this.num}/${this.den}`; }

        add(other) { return new Fraction(this.num * other.den + other.num * this.den, this.den * other.den); }
        subtract(other) { return new Fraction(this.num * other.den - other.num * this.den, this.den * other.den); }
        multiply(other) { return new Fraction(this.num * other.num, this.den * other.den); }
        divide(other) { return new Fraction(this.num * other.den, this.den * other.num); }
        isZero() { return this.num === 0; }
        isOne() { return this.num === 1 && this.den === 1; }
    }

    let currentSize = 3;
    let currentMode = '';
    let g_rowsA = 3, g_colsA = 3;
    let g_rowsB = 3, g_colsB = 3;

    const MODES = {
        'inverse-gauss': { title: 'Ngh·ªãch ƒê·∫£o (Gauss-Jordan)', hasB: false, hasMatrixB: false, func: calculateInverse, color: '#2563eb' },
        'inverse-adj': { title: 'Ngh·ªãch ƒê·∫£o (Ph·∫ßn ph·ª• ƒë·∫°i s·ªë)', hasB: false, hasMatrixB: false, func: calculateInverseByAdjugate, color: '#d97706' },
        'determinant': { title: 'T√≠nh ƒê·ªãnh Th·ª©c', hasB: false, hasMatrixB: false, func: calculateDeterminant, color: '#059669' },
        'determinant-laplace': { title: 'T√≠nh ƒê·ªãnh Th·ª©c (Khai tri·ªÉn Laplace)', hasB: false, hasMatrixB: false, func: calculateDeterminantLaplace, color: '#10b981' },
        'determinant-geo': { title: 'ƒê·ªãnh Th·ª©c & H√¨nh H·ªçc (Area/Volume)', hasB: false, hasMatrixB: false, func: calculateGeometricDeterminant, color: '#0ea5e9' },
        'rank': { title: 'T√¨m H·∫°ng Ma Tr·∫≠n (Rank)', hasB: false, hasMatrixB: false, func: calculateRank, color: '#7c3aed' },
        'linear-system': { title: 'Gi·∫£i H·ªá PT (Ax = B)', hasB: true, hasMatrixB: false, func: solveLinearSystem, color: '#db2777' },
        'eigen': { title: 'T√¨m Gi√° Tr·ªã Ri√™ng', hasB: false, hasMatrixB: false, func: calculateEigenvalues, color: '#0891b2' },
        'multiplication': { title: 'Nh√¢n Ma Tr·∫≠n (A √ó B)', hasB: false, hasMatrixB: true, func: calculateMatrixMultiplication, color: '#8b5cf6' },
        'power': { title: 'L≈©y Th·ª´a Ma Tr·∫≠n (A^k)', hasB: false, hasMatrixB: false, hasK: true, func: calculateMatrixPower, color: '#f59e0b' },
        'laplace': { title: 'Bi·∫øn ƒë·ªïi Laplace', isLaplace: true, isInverse: false, color: '#f59e0b' },
        'inverse-laplace': { title: 'Bi·∫øn ƒë·ªïi Laplace Ng∆∞·ª£c', isLaplace: true, isInverse: true, color: '#d97706' }
    };

    function selectMode(mode) {
        currentMode = mode;
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('calculator-view').style.display = 'block';
        document.getElementById('feature-title').innerText = MODES[mode].title;
        document.getElementById('input-container').style.display = 'none';
        document.getElementById('solution-steps').innerHTML = '';

        // Update Dimension Inputs
        const dimContainer = document.getElementById('dimension-inputs');
        if (mode === 'multiplication') {
            dimContainer.innerHTML = `
                <label>A:</label> <input type="number" id="rowsA" value="2" min="1" max="6"> x <input type="number" id="colsA" value="3" min="1" max="6">
                <span style="margin:0 10px; color:var(--text-muted)">|</span>
                <label>B:</label> <input type="number" id="rowsB" value="3" min="1" max="6"> x <input type="number" id="colsB" value="2" min="1" max="6">
            `;
        } else {
            dimContainer.innerHTML = `<label>K√≠ch th∆∞·ªõc (N x N): </label><input type="number" id="size" value="3" min="2" max="6">`;
        }

        const config = MODES[mode];
        if (config.isLaplace) {
            document.getElementById('matrix-controls').style.display = 'none';
            document.getElementById('laplace-controls').style.display = 'block';
            setupLaplaceUI();
            renderLaplaceTheory();
        } else {
            document.getElementById('matrix-controls').style.display = 'block';
            document.getElementById('laplace-controls').style.display = 'none';
            generateInputs(); // Auto generate inputs for default size
        }
    }

    function goToHome() {
        document.getElementById('main-menu').style.display = 'grid';
        document.getElementById('calculator-view').style.display = 'none';
        document.getElementById('solution-steps').innerHTML = '';
    }

    function createInput(id) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'matrix-cell';
        input.value = Math.floor(Math.random() * 9) + 1;
        input.id = id;
        return input;
    }

    // 1. T·∫°o √¥ nh·∫≠p li·ªáu
    function generateInputs() {
        const config = MODES[currentMode];
        
        if (currentMode === 'multiplication') {
            g_rowsA = parseInt(document.getElementById('rowsA').value) || 2;
            g_colsA = parseInt(document.getElementById('colsA').value) || 3;
            g_rowsB = parseInt(document.getElementById('rowsB').value) || 3;
            g_colsB = parseInt(document.getElementById('colsB').value) || 2;
            currentSize = g_rowsA; // Fallback
        } else {
            currentSize = parseInt(document.getElementById('size').value) || 3;
            g_rowsA = g_colsA = currentSize;
        }

        const container = document.getElementById('matrix-input-area');
        container.innerHTML = '';

        if (config && config.hasMatrixB) {
            container.style.display = 'flex';
            container.style.flexWrap = 'wrap';
            container.style.gap = '20px';
            
            // Matrix A Container
            const divA = document.createElement('div');
            divA.className = 'matrix-wrapper';
            divA.innerHTML = '<div class="matrix-label">Ma tr·∫≠n A</div>';
            const gridA = document.createElement('div');
            gridA.style.display = 'grid';
            gridA.style.gap = '10px';
            for (let i = 0; i < g_rowsA; i++) {
                const rDiv = document.createElement('div');
                rDiv.className = 'matrix-row';
                for (let j = 0; j < g_colsA; j++) {
                    rDiv.appendChild(createInput(`m-${i}-${j}`));
                }
                gridA.appendChild(rDiv);
            }
            divA.appendChild(gridA);
            container.appendChild(divA);

            // Matrix B Container
            const divB = document.createElement('div');
            divB.className = 'matrix-wrapper';
            divB.innerHTML = '<div class="matrix-label">Ma tr·∫≠n B</div>';
            const gridB = document.createElement('div');
            gridB.style.display = 'grid';
            gridB.style.gap = '10px';
            for (let i = 0; i < g_rowsB; i++) {
                const rDiv = document.createElement('div');
                rDiv.className = 'matrix-row';
                for (let j = 0; j < g_colsB; j++) {
                    rDiv.appendChild(createInput(`mb-${i}-${j}`));
                }
                gridB.appendChild(rDiv);
            }
            divB.appendChild(gridB);
            container.appendChild(divB);

        } else if (config) {
            container.style.display = 'grid';
            container.style.gap = '10px';
            
            // Wrap single matrix in a border too for consistency
            const wrapper = document.createElement('div');
            wrapper.className = 'matrix-wrapper';
            wrapper.innerHTML = `<div class="matrix-label">Ma tr·∫≠n A ${config.hasB ? '| Vector B' : ''}</div>`;
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gap = '10px';
            
            for (let i = 0; i < currentSize; i++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'matrix-row';
                for (let j = 0; j < currentSize; j++) {
                    rowDiv.appendChild(createInput(`m-${i}-${j}`));
                }

                if (config.hasB) {
                    // Th√™m c·ªôt vector B
                    const sep = document.createElement('span');
                    sep.innerHTML = '=';
                    sep.style.margin = 'auto 10px';
                    sep.style.fontWeight = 'bold';
                    rowDiv.appendChild(sep);

                    const inputB = createInput(`b-${i}`);
                    inputB.style.backgroundColor = 'rgba(16, 185, 129, 0.2)';
                    inputB.style.borderColor = '#10b981';
                    rowDiv.appendChild(inputB);
                }
                
                grid.appendChild(rowDiv);
            }
            wrapper.appendChild(grid);
            container.appendChild(wrapper);
        }

        if (config && config.hasK) {
            const kDiv = document.createElement('div');
            kDiv.style.width = '100%';
            kDiv.style.display = 'flex';
            kDiv.style.justifyContent = 'center';
            kDiv.style.alignItems = 'center';
            kDiv.style.marginTop = '20px';
            kDiv.innerHTML = '<span style="font-size: 1.1rem; font-weight: 600; margin-right: 10px;">S·ªë m≈© k = </span>';
            const inputK = createInput('exponent-k');
            inputK.value = '2';
            kDiv.appendChild(inputK);
            container.appendChild(kDiv);
        }
        document.getElementById('input-container').style.display = 'block';
        document.getElementById('solution-steps').innerHTML = '';

        // Update Action Button
        const actionArea = document.getElementById('action-area');
        actionArea.innerHTML = '';
        if (config) {
            const btn = document.createElement('button');
            btn.innerText = "T√≠nh To√°n Ngay";
            btn.style.background = config.color;
            btn.style.fontSize = '1.1rem';
            btn.style.padding = '12px 30px';
            btn.onclick = config.func;
            actionArea.appendChild(btn);
        }
    }

    // 2. H√†m l·∫•y d·ªØ li·ªáu t·ª´ UI
    function getMatrixFromInput() {
        let matrix = [];
        for (let i = 0; i < g_rowsA; i++) {
            let row = [];
            for (let j = 0; j < g_colsA; j++) {
                let valStr = document.getElementById(`m-${i}-${j}`).value;
                row.push(Fraction.fromString(valStr));
            }
            matrix.push(row);
        }
        return matrix;
    }

    function getVectorBFromInput() {
        let vector = [];
        for (let i = 0; i < currentSize; i++) {
            let valStr = document.getElementById(`b-${i}`).value;
            vector.push(Fraction.fromString(valStr));
        }
        return vector;
    }

    function getMatrixBFromInput() {
        let matrix = [];
        for (let i = 0; i < g_rowsB; i++) {
            let row = [];
            for (let j = 0; j < g_colsB; j++) {
                let valStr = document.getElementById(`mb-${i}-${j}`).value;
                row.push(Fraction.fromString(valStr));
            }
            matrix.push(row);
        }
        return matrix;
    }

    // 3. H√†m hi·ªÉn th·ªã m·ªôt b∆∞·ªõc (Render HTML)
    function renderStep(matrix, description, pivotRow = -1, pivotCol = -1) {
        const stepsDiv = document.getElementById('solution-steps');
        const stepBox = document.createElement('div');
        stepBox.className = 'step-container';

        let html = `<div class="step-description">${description}</div>`;
        html += `<div style="text-align:center;"><div class="matrix-display"><table>`;

        for (let i = 0; i < matrix.length; i++) {
            html += `<tr>`;
            for (let j = 0; j < matrix[i].length; j++) {
                // T√¥ m√†u ph·∫ßn t·ª≠ ƒëang x·ª≠ l√Ω
                const isPivot = (i === pivotRow && j === pivotCol);
                const isAugmentedSeparator = (j === currentSize); // V·∫°ch ngƒÉn c√°ch [A | I]
                
                let cellClass = isPivot ? 'highlight' : '';
                if (isAugmentedSeparator) cellClass += ' separator';

                // L√†m tr√≤n s·ªë hi·ªÉn th·ªã
                let val = matrix[i][j];
                let displayVal = val.toString();
                
                html += `<td class="${cellClass}">${displayVal}</td>`;
            }
            html += `</tr>`;
        }
        html += `</table></div></div>`;
        
        stepBox.innerHTML = html;
        stepsDiv.appendChild(stepBox);
    }

    // 4. Thu·∫≠t to√°n Gauss-Jordan t√¨m ngh·ªãch ƒë·∫£o
    function calculateInverse() {
        document.getElementById('solution-steps').innerHTML = '<h2>Chi ti·∫øt c√°c b∆∞·ªõc gi·∫£i:</h2>';
        let A = getMatrixFromInput();
        let n = currentSize;

        // T·∫°o ma tr·∫≠n m·ªü r·ªông [A | I]
        let M = [];
        for (let i = 0; i < n; i++) {
            let row = [...A[i]];
            for (let j = 0; j < n; j++) {
                row.push(i === j ? new Fraction(1) : new Fraction(0));
            }
            M.push(row);
        }

        renderStep(M, "B∆∞·ªõc 1: L·∫≠p ma tr·∫≠n m·ªü r·ªông [A | I]");

        // Qu√° tr√¨nh kh·ª≠ Gauss
        for (let i = 0; i < n; i++) {
            // T√¨m pivot (ph·∫ßn t·ª≠ tr·ª•)
            let pivot = M[i][i];
            
            // N·∫øu pivot = 0, c·∫ßn ho√°n ƒë·ªïi h√†ng
            if (pivot.isZero()) {
                // T√¨m h√†ng b√™n d∆∞·ªõi ƒë·ªÉ ƒë·ªïi
                let swapRow = -1;
                for(let k = i + 1; k < n; k++) {
                    if(!M[k][i].isZero()) { swapRow = k; break; }
                }
                if(swapRow !== -1) {
                    [M[i], M[swapRow]] = [M[swapRow], M[i]];
                    renderStep(M, `Ho√°n ƒë·ªïi h√†ng ${i+1} v√† h√†ng ${swapRow+1} ƒë·ªÉ c√≥ ph·∫ßn t·ª≠ tr·ª• kh√°c 0.`);
                    pivot = M[i][i];
                } else {
                    document.getElementById('solution-steps').innerHTML += '<div class="step-container highlight" style="color:red">Ma tr·∫≠n suy bi·∫øn (ƒê·ªãnh th·ª©c = 0), kh√¥ng c√≥ ngh·ªãch ƒë·∫£o!</div>';
                    return;
                }
            }

            // Chia h√†ng i cho pivot ƒë·ªÉ ph·∫ßn t·ª≠ tr·ª• th√†nh 1
            if (!pivot.isOne()) {
                let pivotInv = new Fraction(pivot.den, pivot.num);
                for (let j = 0; j < 2 * n; j++) {
                    M[i][j] = M[i][j].multiply(pivotInv);
                }
                renderStep(M, `Nh√¢n h√†ng ${i+1} v·ªõi ${pivotInv.toString()} ƒë·ªÉ ph·∫ßn t·ª≠ tr·ª• (${i+1},${i+1}) b·∫±ng 1.`, i, i);
            }

            // Kh·ª≠ c√°c h√†ng kh√°c v·ªÅ 0
            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let factor = M[k][i];
                    if (!factor.isZero()) {
                        for (let j = 0; j < 2 * n; j++) {
                            M[k][j] = M[k][j].subtract(factor.multiply(M[i][j]));
                        }
                        renderStep(M, `L·∫•y h√†ng ${k+1} tr·ª´ ƒëi (${factor.toString()}) l·∫ßn h√†ng ${i+1}.`, k, i);
                    }
                }
            }
        }

        // T√°ch k·∫øt qu·∫£
        let inverse = [];
        for(let i=0; i<n; i++) {
            inverse.push(M[i].slice(n, 2*n));
        }
        
        renderStep(inverse, "K·∫øt qu·∫£: Ma tr·∫≠n ngh·ªãch ƒë·∫£o A‚Åª¬π (Ph·∫ßn b√™n ph·∫£i c·ªßa ma tr·∫≠n m·ªü r·ªông)");
        saveToHistory('Ngh·ªãch ƒë·∫£o (Gauss-Jordan)', A, null);
    }

    // --- C√°c h√†m h·ªó tr·ª£ cho ph∆∞∆°ng ph√°p Ph·∫ßn ph·ª• ƒë·∫°i s·ªë ---
    function getMinor(matrix, row, col) {
        return matrix.filter((_, r) => r !== row).map(r => r.filter((_, c) => c !== col));
    }

    function computeDet(matrix) {
        const n = matrix.length;
        if (n === 0) return new Fraction(1);
        if (n === 1) return matrix[0][0];
        if (n === 2) {
            return matrix[0][0].multiply(matrix[1][1]).subtract(matrix[0][1].multiply(matrix[1][0]));
        }
        
        let det = new Fraction(0);
        for (let j = 0; j < n; j++) {
            const minorDet = computeDet(getMinor(matrix, 0, j));
            const term = matrix[0][j].multiply(minorDet);
            det = (j % 2 === 0) ? det.add(term) : det.subtract(term);
        }
        return det;
    }

    function transpose(matrix) {
        if (matrix.length === 0) return [];
        return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
    }

    function matrixToHtmlTable(matrix) {
        let html = '<table style="display:inline-table; vertical-align:middle; border-left:1px solid black; border-right:1px solid black; margin: 0 5px;">';
        for (let row of matrix) {
            html += '<tr>';
            for (let val of row) {
                html += `<td style="padding:2px 5px; text-align:center;">${val.toString()}</td>`;
            }
            html += '</tr>';
        }
        html += '</table>';
        return html;
    }

    function calculateInverseByAdjugate() {
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = '<h2>Chi ti·∫øt t√¨m Ngh·ªãch ƒë·∫£o b·∫±ng Ph·∫ßn ph·ª• ƒë·∫°i s·ªë:</h2>';
        let A = getMatrixFromInput();
        const n = currentSize;

        // --- Step 1: Calculate Determinant ---
        const detA = computeDet(A);
        let step1Html = `<div class="step-description">B∆∞·ªõc 1: T√≠nh ƒë·ªãnh th·ª©c c·ªßa ma tr·∫≠n A.</div>`;
        step1Html += `S·ª≠ d·ª•ng khai tri·ªÉn Laplace, ta c√≥: det(A) = <b>${detA.toString()}</b>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: step1Html}));

        if (detA.isZero()) {
            stepsDiv.innerHTML += `<div class="step-container highlight" style="color:red">det(A) = 0, ma tr·∫≠n kh√¥ng c√≥ ngh·ªãch ƒë·∫£o.</div>`;
            return;
        }

        // --- Step 2: Calculate Cofactor Matrix ---
        stepsDiv.innerHTML += `<div class="step-container"><div class="step-description">B∆∞·ªõc 2: T√¨m ma tr·∫≠n c√°c ph·∫ßn ph·ª• ƒë·∫°i s·ªë C.</div></div>`;
        
        let cofactorMatrix = Array(n).fill(0).map(() => Array(n));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                const minor = getMinor(A, i, j);
                const minorDet = computeDet(minor);
                const sign = ((i + j) % 2 === 0) ? new Fraction(1) : new Fraction(-1);
                cofactorMatrix[i][j] = sign.multiply(minorDet);

                let stepHtml = `T√≠nh C<sub>${i+1}${j+1}</sub> = (-1)<sup>${i+1}+${j+1}</sup> √ó |M<sub>${i+1}${j+1}</sub>| = ${sign.toString()} √ó ${matrixToHtmlTable(minor)} = <b>${cofactorMatrix[i][j].toString()}</b>`;
                stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: stepHtml}));
            }
        }
        renderStep(cofactorMatrix, "Ma tr·∫≠n ph·∫ßn ph·ª• ƒë·∫°i s·ªë C:");

        // --- Step 3 & 4: Adjugate and Inverse ---
        const adjugateMatrix = transpose(cofactorMatrix);
        renderStep(adjugateMatrix, "B∆∞·ªõc 3: T√¨m ma tr·∫≠n ph·ª• h·ª£p adj(A) = C<sup>T</sup>");

        const detInv = new Fraction(1, 1).divide(detA);
        const inverseMatrix = adjugateMatrix.map(row => row.map(val => val.multiply(detInv)));
        
        let finalHtml = `<div class="step-description">B∆∞·ªõc 4: T√≠nh ma tr·∫≠n ngh·ªãch ƒë·∫£o A‚Åª¬π = (1/det(A)) √ó adj(A)</div>`;
        finalHtml += `<div style="font-size: 1.1em; line-height: 1.5;">A‚Åª¬π = ${detInv.toString()} √ó ${matrixToHtmlTable(adjugateMatrix)}</div>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: finalHtml}));

        renderStep(inverseMatrix, "K·∫øt qu·∫£: Ma tr·∫≠n ngh·ªãch ƒë·∫£o A‚Åª¬π");
        saveToHistory('Ngh·ªãch ƒë·∫£o (Ph·∫ßn ph·ª• ƒë·∫°i s·ªë)', A, null);
    }

    function calculateDeterminantLaplace() {
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = '<h2>Chi ti·∫øt t√≠nh ƒê·ªãnh th·ª©c (Khai tri·ªÉn Laplace h√†ng 1):</h2>';
        let A = getMatrixFromInput();
        let n = currentSize;

        if (n === 1) {
             stepsDiv.innerHTML += `<div class="step-container">Ma tr·∫≠n 1x1: Det = ${A[0][0].toString()}</div>`;
             saveToHistory('ƒê·ªãnh Th·ª©c (Laplace)', A, null);
             return;
        }

        // B∆∞·ªõc 1: Hi·ªÉn th·ªã c√¥ng th·ª©c khai tri·ªÉn
        let step1Html = `<div class="step-description">B∆∞·ªõc 1: Khai tri·ªÉn theo h√†ng ƒë·∫ßu ti√™n</div>`;
        step1Html += `<div style="font-size: 1.1em; line-height: 2; overflow-x: auto;">det(A) = `;
        
        let values = [];
        for (let j = 0; j < n; j++) {
            let val = A[0][j];
            let signStr = (j % 2 === 0) ? (j === 0 ? '' : ' + ') : ' - ';
            let minor = getMinor(A, 0, j);
            let minorDet = computeDet(minor);
            
            values.push({ sign: (j % 2 === 0) ? 1 : -1, val: val, minorDet: minorDet });
            step1Html += `${signStr} ${val.toString()} &times; ${matrixToHtmlTable(minor)}`;
        }
        step1Html += `</div>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: step1Html}));

        // B∆∞·ªõc 2: K·∫øt qu·∫£
        let finalDet = computeDet(A);
        let step2Html = `<div class="step-description">B∆∞·ªõc 2: T√≠nh to√°n gi√° tr·ªã c√°c ƒë·ªãnh th·ª©c con v√† t·ªïng h·ª£p</div>`;
        step2Html += `<div> = ` + values.map((v, i) => {
            let s = (i === 0) ? '' : (v.sign > 0 ? ' + ' : ' - ');
            return `${s} ${v.val.toString()} &times; (${v.minorDet.toString()})`;
        }).join("") + `</div>`;
        step2Html += `<br><div class="highlight" style="display:inline-block; padding:5px;">K·∫øt qu·∫£ cu·ªëi c√πng: det(A) = ${finalDet.toString()}</div>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: step2Html}));
        
        saveToHistory('ƒê·ªãnh Th·ª©c (Laplace)', A, null);
    }

    function calculateGeometricDeterminant() {
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = '<h2>Chi ti·∫øt ƒê·ªãnh th·ª©c theo √Ω nghƒ©a H√¨nh h·ªçc:</h2>';
        let A_frac = getMatrixFromInput();
        let n = currentSize;

        if (n !== 2 && n !== 3) {
            stepsDiv.innerHTML += `<div class="step-container highlight" style="color:red">Ch·ª©c nƒÉng bi·ªÉu di·ªÖn h√¨nh h·ªçc ch·ªâ h·ªó tr·ª£ ma tr·∫≠n k√≠ch th∆∞·ªõc 2x2 (Di·ªán t√≠ch) v√† 3x3 (Th·ªÉ t√≠ch).</div>`;
            return;
        }

        // Convert Fraction to float for calculation and plotting
        let A = A_frac.map(row => row.map(val => val.num / val.den));
        
        // Get column vectors
        let vectors = [];
        for(let j=0; j<n; j++) {
            let vec = [];
            for(let i=0; i<n; i++) vec.push(A[i][j]);
            vectors.push(vec);
        }

        let resultHtml = '';
        let plotData = [];
        let layout = {};

        if (n === 2) {
            // 2D Case: Area of Parallelogram
            let u = vectors[0]; // [x1, y1]
            let v = vectors[1]; // [x2, y2]
            
            // Geometric calculation: Cross product in 2D (ad - bc)
            let detVal = u[0]*v[1] - u[1]*v[0];
            
            resultHtml += `<div class="step-container">
                <div class="step-description">√ù nghƒ©a h√¨nh h·ªçc (2D)</div>
                <div>ƒê·ªãnh th·ª©c c·ªßa ma tr·∫≠n 2x2 ƒë·∫°i di·ªán cho <b>Di·ªán t√≠ch c√≥ h∆∞·ªõng</b> c·ªßa h√¨nh b√¨nh h√†nh t·∫°o b·ªüi hai vector c·ªôt.</div>
                <ul style="margin: 10px 0;">
                    <li>Vector c·ªôt 1: <b>u</b> = (${u[0]}, ${u[1]})</li>
                    <li>Vector c·ªôt 2: <b>v</b> = (${v[0]}, ${v[1]})</li>
                </ul>
                <div style="font-size: 1.1em;">Di·ªán t√≠ch = | det(A) | = | ${u[0]} √ó ${v[1]} - ${u[1]} √ó ${v[0]} | = | ${detVal} | = <b>${Math.abs(detVal)}</b></div>
            </div>`;
            
            // Plotly 2D Data
            // Parallelogram points: (0,0) -> u -> u+v -> v -> (0,0)
            let x = [0, u[0], u[0]+v[0], v[0], 0];
            let y = [0, u[1], u[1]+v[1], v[1], 0];
            
            plotData = [
                { x: x, y: y, fill: 'toself', type: 'scatter', mode: 'lines+markers', name: 'H√¨nh b√¨nh h√†nh', fillcolor: 'rgba(14, 165, 233, 0.2)', line: {color: '#0ea5e9'} },
                { x: [0, u[0]], y: [0, u[1]], type: 'scatter', mode: 'lines+text', name: 'u', line: {color: '#ef4444', width: 3}, text: ['','u'], textposition: 'top right', textfont: {color: '#ef4444'} },
                { x: [0, v[0]], y: [0, v[1]], type: 'scatter', mode: 'lines+text', name: 'v', line: {color: '#22c55e', width: 3}, text: ['','v'], textposition: 'top right', textfont: {color: '#22c55e'} }
            ];
            layout = {
                title: { text: 'Bi·ªÉu di·ªÖn H√¨nh b√¨nh h√†nh', font: { color: '#f1f5f9' } },
                xaxis: { title: 'x', color: '#94a3b8', gridcolor: '#334155', zerolinecolor: '#475569', automargin: true },
                yaxis: { title: 'y', scaleanchor: "x", scaleratio: 1, color: '#94a3b8', gridcolor: '#334155', zerolinecolor: '#475569', automargin: true },
                showlegend: true, 
                legend: { font: { color: '#f1f5f9' } },
                margin: {t: 60, b: 40, l: 40, r: 40},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                autosize: true
            };

        } else {
            // 3D Case: Volume of Parallelepiped
            let u = vectors[0];
            let v = vectors[1];
            let w = vectors[2];

            // Cross product u x v
            let cross_x = u[1]*v[2] - u[2]*v[1];
            let cross_y = u[2]*v[0] - u[0]*v[2];
            let cross_z = u[0]*v[1] - u[1]*v[0];
            
            // Dot product (u x v) . w
            let detVal = cross_x*w[0] + cross_y*w[1] + cross_z*w[2];

            resultHtml += `<div class="step-container">
                <div class="step-description">√ù nghƒ©a h√¨nh h·ªçc (3D)</div>
                <div>ƒê·ªãnh th·ª©c c·ªßa ma tr·∫≠n 3x3 l√† <b>Th·ªÉ t√≠ch c√≥ h∆∞·ªõng</b> c·ªßa h√¨nh h·ªôp (parallelepiped) t·∫°o b·ªüi ba vector c·ªôt, t√≠nh b·∫±ng <b>T√≠ch h·ªón t·∫°p</b> (Scalar Triple Product).</div>
                <div style="margin: 10px 0; font-family: monospace;">
                    u = (${u.join(', ')})<br>v = (${v.join(', ')})<br>w = (${w.join(', ')})
                </div>
                <div class="step-description">B∆∞·ªõc 1: T√≠nh t√≠ch c√≥ h∆∞·ªõng <b>p</b> = <b>u</b> √ó <b>v</b></div>
                <div><b>p</b> = (${u[1]}‚ãÖ${v[2]} - ${u[2]}‚ãÖ${v[1]}, ${u[2]}‚ãÖ${v[0]} - ${u[0]}‚ãÖ${v[2]}, ${u[0]}‚ãÖ${v[1]} - ${u[1]}‚ãÖ${v[0]})</div>
                <div><b>p</b> = (${cross_x}, ${cross_y}, ${cross_z})</div>
                <br>
                <div class="step-description">B∆∞·ªõc 2: T√≠nh t√≠ch v√¥ h∆∞·ªõng Vol = <b>p</b> ‚ãÖ <b>w</b></div>
                <div>Vol = ${cross_x}‚ãÖ${w[0]} + ${cross_y}‚ãÖ${w[1]} + ${cross_z}‚ãÖ${w[2]} = <b>${detVal}</b></div>
                <div style="margin-top:5px;">Th·ªÉ t√≠ch kh·ªëi h·ªôp = |${detVal}| = <b>${Math.abs(detVal)}</b></div>
            </div>`;

            // Plotly 3D Data - Draw vectors and the box edges
            // Vertices: 0, u, v, w, u+v, u+w, v+w, u+v+w
            // We draw lines connecting them
            let O=[0,0,0];
            let sum_uv = [u[0]+v[0], u[1]+v[1], u[2]+v[2]];
            let sum_uw = [u[0]+w[0], u[1]+w[1], u[2]+w[2]];
            let sum_vw = [v[0]+w[0], v[1]+w[1], v[2]+w[2]];
            let sum_all = [u[0]+v[0]+w[0], u[1]+v[1]+w[1], u[2]+v[2]+w[2]];

            // Constructing lines for the box
            let x_lines = [0, u[0], sum_uv[0], v[0], 0, w[0], sum_uw[0], sum_all[0], sum_vw[0], w[0], null, u[0], sum_uw[0], null, v[0], sum_vw[0], null, sum_uv[0], sum_all[0]];
            let y_lines = [0, u[1], sum_uv[1], v[1], 0, w[1], sum_uw[1], sum_all[1], sum_vw[1], w[1], null, u[1], sum_uw[1], null, v[1], sum_vw[1], null, sum_uv[1], sum_all[1]];
            let z_lines = [0, u[2], sum_uv[2], v[2], 0, w[2], sum_uw[2], sum_all[2], sum_vw[2], w[2], null, u[2], sum_uw[2], null, v[2], sum_vw[2], null, sum_uv[2], sum_all[2]];

            plotData = [{ type: 'scatter3d', mode: 'lines', x: x_lines, y: y_lines, z: z_lines, line: {width: 4, color: '#0ea5e9'}, name: 'H√¨nh h·ªôp' }];
            layout = {
                title: { text: 'Bi·ªÉu di·ªÖn H√¨nh h·ªôp (3D)', font: { color: '#f1f5f9' } },
                scene: { 
                    aspectmode: "data",
                    xaxis: { title: 'x', color: '#94a3b8', gridcolor: '#334155', backgroundcolor: 'rgba(0,0,0,0)', showbackground: false, automargin: true },
                    yaxis: { title: 'y', color: '#94a3b8', gridcolor: '#334155', backgroundcolor: 'rgba(0,0,0,0)', showbackground: false, automargin: true },
                    zaxis: { title: 'z', color: '#94a3b8', gridcolor: '#334155', backgroundcolor: 'rgba(0,0,0,0)', showbackground: false, automargin: true }
                },
                margin: {t: 60, b: 0, l: 0, r: 0},
                height: 500,
                paper_bgcolor: 'rgba(0,0,0,0)',
                autosize: true
            };
        }

        stepsDiv.innerHTML += resultHtml + `<div id="geo-plot" style="width:100%; height:500px; border-radius:8px; margin-top:15px;"></div>`;
        Plotly.newPlot('geo-plot', plotData, layout);
        saveToHistory('ƒê·ªãnh Th·ª©c (H√¨nh H·ªçc)', A_frac, null);
    }

    // 6. H√†m t√≠nh ƒê·ªãnh th·ª©c (Determinant) b·∫±ng bi·∫øn ƒë·ªïi s∆° c·∫•p
    function calculateDeterminant() {
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = '<h2>Chi ti·∫øt t√≠nh ƒê·ªãnh th·ª©c (Bi·∫øn ƒë·ªïi v·ªÅ d·∫°ng tam gi√°c tr√™n):</h2>';
        let A = getMatrixFromInput();
        let n = currentSize;
        
        // Copy matrix
        let M = A.map(row => row.map(val => new Fraction(val.num, val.den)));
        let detSign = new Fraction(1);
        
        renderStep(M, "Ma tr·∫≠n ban ƒë·∫ßu");

        for (let i = 0; i < n; i++) {
            // 1. T√¨m tr·ª• (Pivot)
            let pivot = M[i][i];
            
            // N·∫øu tr·ª• b·∫±ng 0, t√¨m h√†ng d∆∞·ªõi ƒë·ªÉ ƒë·ªïi
            if (pivot.isZero()) {
                let swapRow = -1;
                for (let k = i + 1; k < n; k++) {
                    if (!M[k][i].isZero()) {
                        swapRow = k;
                        break;
                    }
                }
                
                if (swapRow !== -1) {
                    [M[i], M[swapRow]] = [M[swapRow], M[i]];
                    detSign = detSign.multiply(new Fraction(-1));
                    renderStep(M, `Ho√°n ƒë·ªïi h√†ng ${i+1} v√† h√†ng ${swapRow+1} (ƒê·ªãnh th·ª©c ƒë·ªïi d·∫•u).`, i, i);
                    pivot = M[i][i];
                } else {
                    // C·ªôt to√†n s·ªë 0 => ƒê·ªãnh th·ª©c = 0
                    stepsDiv.innerHTML += `<div class="step-container highlight" style="color:red; text-align:center; font-size: 1.2em;">
                        C·ªôt ${i+1} ch·ª©a to√†n s·ªë 0 t·∫°i v·ªã tr√≠ ƒë∆∞·ªùng ch√©o tr·ªü xu·ªëng.<br>
                        => ƒê·ªãnh th·ª©c = 0
                    </div>`;
                    return;
                }
            }

            // 2. Kh·ª≠ c√°c ph·∫ßn t·ª≠ b√™n d∆∞·ªõi tr·ª• v·ªÅ 0
            for (let k = i + 1; k < n; k++) {
                let factor = M[k][i].divide(pivot);
                if (!factor.isZero()) {
                    for (let j = i; j < n; j++) {
                        M[k][j] = M[k][j].subtract(factor.multiply(M[i][j]));
                    }
                    renderStep(M, `L·∫•y h√†ng ${k+1} tr·ª´ ƒëi (${factor.toString()}) l·∫ßn h√†ng ${i+1} (ƒê·ªãnh th·ª©c kh√¥ng ƒë·ªïi).`, k, i);
                }
            }
        }

        // 3. T√≠nh t√≠ch ƒë∆∞·ªùng ch√©o
        let detVal = detSign;
        let diagHtml = [];
        for (let i = 0; i < n; i++) {
            detVal = detVal.multiply(M[i][i]);
            diagHtml.push(M[i][i].toString());
        }

        let resultHtml = `<div class="step-description">B∆∞·ªõc cu·ªëi: T√≠nh t√≠ch c√°c ph·∫ßn t·ª≠ tr√™n ƒë∆∞·ªùng ch√©o ch√≠nh</div>`;
        resultHtml += `<div style="font-size: 1.1em; line-height: 1.5;">`;
        resultHtml += `det(A) = (D·∫•u do ho√°n ƒë·ªïi) √ó (T√≠ch ƒë∆∞·ªùng ch√©o)<br>`;
        resultHtml += `det(A) = ${detSign.toString()} √ó (${diagHtml.join(' √ó ')})<br>`;
        resultHtml += `</div>`;
        resultHtml += `<br><div class="highlight" style="display:inline-block; padding:10px; font-size: 1.2em; color: #059669;">K·∫øt qu·∫£: det(A) = ${detVal.toString()}</div>`;
        
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: resultHtml}));
        saveToHistory('T√≠nh ƒê·ªãnh th·ª©c', A, null);
    }

    // 8. H√†m gi·∫£i h·ªá ph∆∞∆°ng tr√¨nh tuy·∫øn t√≠nh Ax = B
    function solveLinearSystem() {
        document.getElementById('solution-steps').innerHTML = '<h2>Chi ti·∫øt gi·∫£i h·ªá ph∆∞∆°ng tr√¨nh Ax = B:</h2>';
        let A = getMatrixFromInput();
        let B = getVectorBFromInput();
        let n = currentSize;

        // T·∫°o ma tr·∫≠n m·ªü r·ªông [A | B]
        let M = [];
        for (let i = 0; i < n; i++) {
            let row = [...A[i]];
            row.push(B[i]);
            M.push(row);
        }

        renderStep(M, "B∆∞·ªõc 1: L·∫≠p ma tr·∫≠n m·ªü r·ªông [A | B]");

        // Gauss-Jordan
        for (let i = 0; i < n; i++) {
            let pivot = M[i][i];
            
            if (pivot.isZero()) {
                let swapRow = -1;
                for (let k = i + 1; k < n; k++) {
                    if (!M[k][i].isZero()) { swapRow = k; break; }
                }
                if (swapRow !== -1) {
                    [M[i], M[swapRow]] = [M[swapRow], M[i]];
                    renderStep(M, `Ho√°n ƒë·ªïi h√†ng ${i+1} v√† h√†ng ${swapRow+1}.`, i, i);
                    pivot = M[i][i];
                }
            }

            if (!pivot.isZero()) {
                if (!pivot.isOne()) {
                    let pivotInv = new Fraction(pivot.den, pivot.num);
                    for (let j = i; j <= n; j++) M[i][j] = M[i][j].multiply(pivotInv);
                    renderStep(M, `Bi·∫øn ƒë·ªïi h√†ng ${i+1} ƒë·ªÉ ph·∫ßn t·ª≠ tr·ª• b·∫±ng 1.`, i, i);
                }

                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        let factor = M[k][i];
                        if (!factor.isZero()) {
                            for (let j = i; j <= n; j++) M[k][j] = M[k][j].subtract(factor.multiply(M[i][j]));
                            renderStep(M, `Kh·ª≠ ph·∫ßn t·ª≠ ·ªü h√†ng ${k+1}, c·ªôt ${i+1}.`, k, i);
                        }
                    }
                }
            }
        }

        // Ki·ªÉm tra k·∫øt qu·∫£
        // N·∫øu ƒë∆∞·ªùng ch√©o ch√≠nh ƒë·ªÅu l√† 1 -> Nghi·ªám duy nh·∫•t n·∫±m ·ªü c·ªôt cu·ªëi c√πng
        // N·∫øu c√≥ h√†ng d·∫°ng [0 0 ... 0 | k] v·ªõi k != 0 -> V√¥ nghi·ªám
        renderStep(M, "K·∫øt qu·∫£: Ma tr·∫≠n sau khi bi·∫øn ƒë·ªïi (C·ªôt cu·ªëi c√πng l√† nghi·ªám n·∫øu h·ªá c√≥ nghi·ªám duy nh·∫•t)");
        saveToHistory('Gi·∫£i H·ªá PT (Ax=B)', A, B);
    }

    // H√†m nh√¢n hai ma tr·∫≠n
    function calculateMatrixMultiplication() {
        document.getElementById('solution-steps').innerHTML = '<h2>Chi ti·∫øt nh√¢n hai ma tr·∫≠n C = A √ó B:</h2>';
        let A = getMatrixFromInput();
        let B = getMatrixBFromInput();
        
        if (g_colsA !== g_rowsB) {
            alert(`Kh√¥ng th·ªÉ nh√¢n ma tr·∫≠n! S·ªë c·ªôt c·ªßa A (${g_colsA}) ph·∫£i b·∫±ng s·ªë h√†ng c·ªßa B (${g_rowsB}).`);
            return;
        }

        renderStep(A, "Ma tr·∫≠n A");
        renderStep(B, "Ma tr·∫≠n B");

        let C = Array(g_rowsA).fill(0).map(() => Array(g_colsB));
        let stepsHtml = `<div class="step-container"><div class="step-description">T√≠nh to√°n t·ª´ng ph·∫ßn t·ª≠ c·ªßa ma tr·∫≠n k·∫øt qu·∫£ C:</div><ul style="list-style: none; padding-left: 0;">`;

        for (let i = 0; i < g_rowsA; i++) {
            for (let j = 0; j < g_colsB; j++) {
                let sum = new Fraction(0);
                let formulaParts = [];
                for (let k = 0; k < g_colsA; k++) {
                    let prod = A[i][k].multiply(B[k][j]);
                    sum = sum.add(prod);
                    formulaParts.push(`(${A[i][k].toString()} √ó ${B[k][j].toString()})`);
                }
                C[i][j] = sum;
                stepsHtml += `<li style="margin-bottom: 5px;">C<sub>${i+1}${j+1}</sub> = (H√†ng ${i+1} c·ªßa A) ‚Ä¢ (C·ªôt ${j+1} c·ªßa B) = ${formulaParts.join(' + ')} = <b>${sum.toString()}</b></li>`;
            }
        }
        stepsHtml += `</ul></div>`;
        document.getElementById('solution-steps').innerHTML += stepsHtml;

        renderStep(C, "K·∫øt qu·∫£: Ma tr·∫≠n t√≠ch C = A √ó B");
        saveToHistory('Nh√¢n Ma Tr·∫≠n (AxB)', A, null);
    }

    // H√†m t√≠nh l≈©y th·ª´a ma tr·∫≠n
    function calculateMatrixPower() {
        document.getElementById('solution-steps').innerHTML = '<h2>Chi ti·∫øt t√≠nh L≈©y th·ª´a Ma tr·∫≠n A^k:</h2>';
        let A = getMatrixFromInput();
        let kInput = document.getElementById('exponent-k');
        let k = parseInt(kInput ? kInput.value : 1);
        let n = currentSize;

        if (isNaN(k) || k < 1) {
            alert("Vui l√≤ng nh·∫≠p s·ªë m≈© k nguy√™n d∆∞∆°ng.");
            return;
        }

        renderStep(A, "Ma tr·∫≠n A");

        if (k === 1) {
            renderStep(A, "K·∫øt qu·∫£: A^1 = A");
            return;
        }

        let Result = A; // A^1
        
        for (let exp = 2; exp <= k; exp++) {
            let Next = Array(n).fill(0).map(() => Array(n));
            for(let i=0; i<n; i++) {
                for(let j=0; j<n; j++) {
                    let sum = new Fraction(0);
                    for(let x=0; x<n; x++) sum = sum.add(Result[i][x].multiply(A[x][j]));
                    Next[i][j] = sum;
                }
            }
            Result = Next;
            renderStep(Result, `L≈©y th·ª´a b·∫≠c ${exp}: A^${exp} = A^${exp-1} √ó A`);
        }
        saveToHistory(`L≈©y th·ª´a A^${k}`, A, null);
    }

    // 9. H√†m t√≠nh Gi√° tr·ªã ri√™ng (Eigenvalues)
    function multiplyMatrices(A, B) {
        const n = A.length;
        let C = Array(n).fill(0).map(() => Array(n));
        for(let i=0; i<n; i++) {
            for(let j=0; j<n; j++) {
                let sum = new Fraction(0);
                for(let k=0; k<n; k++) sum = sum.add(A[i][k].multiply(B[k][j]));
                C[i][j] = sum;
            }
        }
        return C;
    }

    function calculateEigenvalues() {
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = '<h2>Chi ti·∫øt t√¨m Gi√° tr·ªã ri√™ng (Eigenvalues):</h2>';
        let A = getMatrixFromInput();
        let n = currentSize;

        // B∆∞·ªõc 1: T√¨m ƒëa th·ª©c ƒë·∫∑c tr∆∞ng b·∫±ng thu·∫≠t to√°n Faddeev‚ÄìLe Verrier
        // P(Œª) = Œª^n - p_1*Œª^(n-1) - p_2*Œª^(n-2) - ... - p_n
        let p = []; // L∆∞u c√°c h·ªá s·ªë p_1, p_2, ...
        let B = A.map(row => row.map(val => new Fraction(val.num, val.den))); // B_1 = A
        
        let step1Html = `<div class="step-description">B∆∞·ªõc 1: T√¨m ƒëa th·ª©c ƒë·∫∑c tr∆∞ng P(Œª) = det(ŒªI - A)</div>`;
        step1Html += `<div>S·ª≠ d·ª•ng thu·∫≠t to√°n Faddeev‚ÄìLe Verrier ƒë·ªÉ x√°c ƒë·ªãnh h·ªá s·ªë:</div><ul style="list-style-type: none;">`;

        for (let k = 1; k <= n; k++) {
            // T√≠nh trace(B)
            let tr = new Fraction(0);
            for(let i=0; i<n; i++) tr = tr.add(B[i][i]);
            
            // p_k = trace(B) / k
            let p_k = tr.divide(new Fraction(k));
            p.push(p_k);
            
            step1Html += `<li>k=${k}: tr(B<sub>${k}</sub>) = ${tr.toString()} => p<sub>${k}</sub> = ${p_k.toString()}</li>`;

            if (k < n) {
                // M = B - p_k * I
                let M = B.map((row, i) => row.map((val, j) => i === j ? val.subtract(p_k) : val));
                // B_next = A * M
                B = multiplyMatrices(A, M);
            }
        }
        step1Html += `</ul>`;
        
        // Hi·ªÉn th·ªã ƒëa th·ª©c
        let polyStr = `Œª<sup>${n}</sup>`;
        for(let i=0; i<n; i++) {
            let val = p[i];
            if (val.isZero()) continue;
            let sign = val.num > 0 ? " - " : " + "; // V√¨ c√¥ng th·ª©c l√† - p_k
            let absVal = new Fraction(Math.abs(val.num), val.den).toString();
            polyStr += `${sign}${absVal}Œª<sup>${n-1-i}</sup>`;
        }
        polyStr = polyStr.replace("Œª<sup>0</sup>", "").replace("Œª<sup>1</sup>", "Œª");
        step1Html += `<div class="highlight" style="padding:10px; margin-top:10px;">ƒêa th·ª©c ƒë·∫∑c tr∆∞ng: P(Œª) = ${polyStr} = 0</div>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: step1Html}));

        // B∆∞·ªõc 2: Gi·∫£i nghi·ªám ƒëa th·ª©c (Durand-Kerner method)
        // Coefficients for x^n + a_{n-1}x^{n-1} + ... + a_0 = 0
        // a_{n-k} = -p_k
        let coeffs = [1];
        for(let val of p) coeffs.push(-val.num / val.den);

        // Solver (T√¨m nghi·ªám ph·ª©c)
        let roots = [];
        for(let i=0; i<n; i++) {
            let angle = 2 * Math.PI * i / n + 0.1; // Offset angle
            roots.push({re: Math.cos(angle), im: Math.sin(angle)});
        }

        for(let iter=0; iter<100; iter++) {
            for(let i=0; i<n; i++) {
                let z = roots[i];
                // Eval P(z)
                let pVal = {re: coeffs[0], im: 0};
                for(let k=1; k<=n; k++) {
                    pVal = {re: pVal.re * z.re - pVal.im * z.im + coeffs[k], im: pVal.re * z.im + pVal.im * z.re};
                }
                // Eval Product (z - z_j)
                let prod = {re: 1, im: 0};
                for(let j=0; j<n; j++) {
                    if (i === j) continue;
                    let diff = {re: z.re - roots[j].re, im: z.im - roots[j].im};
                    prod = {re: prod.re * diff.re - prod.im * diff.im, im: prod.re * diff.im + prod.im * diff.re};
                }
                // Delta = P(z) / Prod
                let denom = prod.re * prod.re + prod.im * prod.im;
                let delta = {re: (pVal.re * prod.re + pVal.im * prod.im)/denom, im: (pVal.im * prod.re - pVal.re * prod.im)/denom};
                roots[i].re -= delta.re; roots[i].im -= delta.im;
            }
        }

        let resultHtml = `<div class="step-description">B∆∞·ªõc 2: Gi·∫£i ph∆∞∆°ng tr√¨nh ƒëa th·ª©c ƒë·ªÉ t√¨m nghi·ªám (Gi√° tr·ªã ri√™ng)</div>`;
        resultHtml += `<ul>`;
        roots.forEach((r, idx) => {
            let re = Math.abs(r.re) < 1e-9 ? 0 : r.re;
            let im = Math.abs(r.im) < 1e-9 ? 0 : r.im;
            let valStr = re.toFixed(4);
            if (im !== 0) valStr += (im > 0 ? " + " : " - ") + Math.abs(im).toFixed(4) + "i";
            resultHtml += `<li>Œª<sub>${idx+1}</sub> ‚âà <b>${valStr}</b></li>`;
        });
        resultHtml += `</ul>`;
        stepsDiv.appendChild(Object.assign(document.createElement('div'), {className: 'step-container', innerHTML: resultHtml}));
        
        findAndDisplayEigenvectors(roots, A);
        saveToHistory('T√¨m Gi√° tr·ªã ri√™ng & Vector ri√™ng', A, null);
    }

    // --- C√°c h√†m cho Vector ri√™ng ---

    class Complex {
        constructor(re = 0, im = 0) {
            this.re = re;
            this.im = im;
        }
        add(other) { return new Complex(this.re + other.re, this.im + other.im); }
        subtract(other) { return new Complex(this.re - other.re, this.im - other.im); }
        multiply(other) {
            const re = this.re * other.re - this.im * other.im;
            const im = this.re * other.im + this.im * other.re;
            return new Complex(re, im);
        }
        divide(other) {
            const denom = other.re * other.re + other.im * other.im;
            if (denom === 0) return new Complex(NaN, NaN);
            const re = (this.re * other.re + this.im * other.im) / denom;
            const im = (this.im * other.re - this.re * other.im) / denom;
            return new Complex(re, im);
        }
        magnitude() { return Math.sqrt(this.re * this.re + this.im * this.im); }
        isZero(tolerance = 1e-9) { return this.magnitude() < tolerance; }
        toString(precision = 4) {
            const rePart = Math.abs(this.re) < 1e-9 ? 0 : this.re;
            const imPart = Math.abs(this.im) < 1e-9 ? 0 : this.im;
            if (imPart === 0) return rePart.toFixed(precision);
            if (rePart === 0) return `${imPart.toFixed(precision)}i`;
            return `${rePart.toFixed(precision)} ${imPart > 0 ? '+' : '-'} ${Math.abs(imPart).toFixed(precision)}i`;
        }
    }

    function renderComplexMatrixStep(matrix, description) {
        const stepsDiv = document.getElementById('solution-steps');
        const stepBox = document.createElement('div');
        stepBox.className = 'step-container';
        let html = `<div class="step-description">${description}</div>`;
        html += `<div style="text-align:center; overflow-x:auto;"><div class="matrix-display"><table>`;
        for (let i = 0; i < matrix.length; i++) {
            html += `<tr>`;
            for (let j = 0; j < matrix[i].length; j++) {
                html += `<td style="padding: 5px 8px; min-width: 80px;">${matrix[i][j].toString(2)}</td>`;
            }
            html += `</tr>`;
        }
        html += `</table></div></div>`;
        stepBox.innerHTML = html;
        stepsDiv.appendChild(stepBox);
    }

    function renderEigenvectors(eigenvalue, basis) {
        const stepsDiv = document.getElementById('solution-steps');
        const stepBox = document.createElement('div');
        stepBox.className = 'step-container';
        let html = `<div class="step-description">Vector ri√™ng ·ª©ng v·ªõi gi√° tr·ªã ri√™ng Œª ‚âà ${eigenvalue.toString(4)}:</div>`;
        if (basis.length === 0) {
            html += `<div>Kh√¥ng gian ri√™ng l√† vector kh√¥ng {0} (c√≥ th·ªÉ do l·ªói t√≠nh to√°n).</div>`;
        } else {
            html += `<div>Kh√¥ng gian ri√™ng (eigenspace) ƒë∆∞·ª£c sinh b·ªüi c√°c vector c∆° s·ªü:</div>`;
            basis.forEach((vector, i) => {
                const columnVector = vector.map(c => [c.toString(2)]);
                html += `<div style="display: inline-block; vertical-align: top; margin: 10px;">v<sub>${i+1}</sub> = ${matrixToHtmlTable(columnVector)}</div>`;
            });
        }
        stepBox.innerHTML = html;
        stepsDiv.appendChild(stepBox);
    }

    function gaussJordanComplex(matrix) {
        const M = matrix.map(row => row.map(c => new Complex(c.re, c.im)));
        const rows = M.length;
        const cols = M[0].length;
        let pivotRow = 0;
        for (let col = 0; col < cols && pivotRow < rows; col++) {
            let i_max = pivotRow;
            for (let i = pivotRow + 1; i < rows; i++) {
                if (M[i][col].magnitude() > M[i_max][col].magnitude()) i_max = i;
            }
            [M[pivotRow], M[i_max]] = [M[i_max], M[pivotRow]];
            let pivot = M[pivotRow][col];
            if (pivot.isZero()) continue;
            let pivotInv = new Complex(1, 0).divide(pivot);
            for (let j = col; j < cols; j++) M[pivotRow][j] = M[pivotRow][j].multiply(pivotInv);
            for (let i = 0; i < rows; i++) {
                if (i !== pivotRow) {
                    let factor = M[i][col];
                    for (let j = col; j < cols; j++) M[i][j] = M[i][j].subtract(factor.multiply(M[pivotRow][j]));
                }
            }
            pivotRow++;
        }
        return M;
    }

    function findAndDisplayEigenvectors(eigenvalues, matrixA) {
        const n = matrixA.length;
        const stepsDiv = document.getElementById('solution-steps');
        let headerHtml = `<div class="step-container"><div class="step-description" style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">B∆∞·ªõc 3: T√¨m vector ri√™ng cho m·ªói gi√° tr·ªã ri√™ng</div></div>`;
        stepsDiv.insertAdjacentHTML('beforeend', headerHtml);

        eigenvalues.forEach((lambda, index) => {
            const M = Array(n).fill(0).map(() => Array(n));
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const a_ij = new Complex(matrixA[i][j].num / matrixA[i][j].den, 0);
                    M[i][j] = (i === j) ? a_ij.subtract(lambda) : a_ij;
                }
            }
            renderComplexMatrixStep(M, `Thi·∫øt l·∫≠p h·ªá (A - ŒªI)x = 0 v·ªõi Œª<sub>${index+1}</sub> ‚âà ${lambda.toString(4)}`);
            const rrefM = gaussJordanComplex(M);
            renderComplexMatrixStep(rrefM, `ƒê∆∞a v·ªÅ d·∫°ng b·∫≠c thang r√∫t g·ªçn (RREF)`);
            const basis = findNullSpace(rrefM);
            renderEigenvectors(lambda, basis);
        });
    }

    function findNullSpace(rrefMatrix) {
        const rows = rrefMatrix.length;
        const cols = rrefMatrix[0].length;
        const basis = [];
        const pivotCols = [];
        let lastPivotRow = -1;
        for (let j = 0; j < cols && lastPivotRow < rows - 1; j++) {
            let pivotRow = -1;
            for (let i = lastPivotRow + 1; i < rows; i++) {
                if (!rrefMatrix[i][j].isZero()) { pivotRow = i; break; }
            }
            if (pivotRow !== -1) {
                pivotCols[j] = pivotRow;
                lastPivotRow = pivotRow;
            }
        }
        for (let j = 0; j < cols; j++) {
            if (pivotCols[j] === undefined) {
                const vector = Array(cols).fill(new Complex(0, 0));
                vector[j] = new Complex(1, 0);
                for (let pivotCol = 0; pivotCol < j; pivotCol++) {
                    if (pivotCols[pivotCol] !== undefined) {
                        const pivotRow = pivotCols[pivotCol];
                        vector[pivotCol] = rrefMatrix[pivotRow][j].multiply(new Complex(-1, 0));
                    }
                }
                basis.push(vector);
            }
        }
        return basis;
    }

    // 10. H√†m xu·∫•t ·∫£nh
    function exportToImage() {
        const element = document.body;
        html2canvas(element, {
            ignoreElements: (node) => node.classList && node.classList.contains('export-buttons')
        }).then(canvas => {
            const link = document.createElement('a');
            link.download = 'giai-bai-tap-dai-so.png';
            link.href = canvas.toDataURL();
            link.click();
        });
    }

    // 11. H√†m nh·∫≠p t·ª´ CSV
    function populateMatrixFromCSV(data) {
        const cleanData = data.filter(row => row.length > 1 || (row.length === 1 && row[0].trim() !== ''));
        if (cleanData.length === 0) {
            alert("L·ªói: File CSV tr·ªëng ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá.");
            return;
        }

        const numRows = cleanData.length;
        const numCols = cleanData[0].length;

        if (numRows > 6 || numCols > 7) {
            alert("L·ªói: K√≠ch th∆∞·ªõc ma tr·∫≠n qu√° l·ªõn. C√¥ng c·ª• ch·ªâ h·ªó tr·ª£ t·ªëi ƒëa 6x6.");
            return;
        }

        if (numRows !== numCols && numRows !== (numCols - 1)) {
            alert(`L·ªói: D·ªØ li·ªáu kh√¥ng ph·∫£i l√† ma tr·∫≠n vu√¥ng (N x N) ho·∫∑c ma tr·∫≠n m·ªü r·ªông (N x N+1). K√≠ch th∆∞·ªõc hi·ªán t·∫°i: ${numRows}x${numCols}`);
            return;
        }
        
        const matrixSize = numRows;
        const hasBVector = numCols === numRows + 1;

        document.getElementById('size').value = matrixSize;
        generateInputs(); // T·∫°o l·∫°i l∆∞·ªõi input

        for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
                const inputA = document.getElementById(`m-${i}-${j}`);
                if (inputA && cleanData[i] && cleanData[i][j] !== undefined) {
                    inputA.value = cleanData[i][j].trim();
                }
            }
            if (hasBVector) {
                const inputB = document.getElementById(`b-${i}`);
                if (inputB && cleanData[i] && cleanData[i][matrixSize] !== undefined) {
                    inputB.value = cleanData[i][matrixSize].trim();
                }
            }
        }
        
        alert(`ƒê√£ t·∫£i l√™n th√†nh c√¥ng ma tr·∫≠n k√≠ch th∆∞·ªõc ${matrixSize}x${numCols}.`);
    }

    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        Papa.parse(file, {
            complete: (results) => populateMatrixFromCSV(results.data),
            error: (error) => alert("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc file CSV. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë·ªãnh d·∫°ng file.")
        });
        event.target.value = ''; // Reset ƒë·ªÉ c√≥ th·ªÉ ch·ªçn l·∫°i c√πng 1 file
    }

    // 7. H√†m t√≠nh H·∫°ng c·ªßa Ma tr·∫≠n (Rank)
    function calculateRank() {
        document.getElementById('solution-steps').innerHTML = '<h2>Chi ti·∫øt t√¨m H·∫°ng c·ªßa Ma tr·∫≠n (Rank):</h2>';
        let A = getMatrixFromInput();
        let n = currentSize;
        // Copy ma tr·∫≠n (deep copy v·ªõi Fraction)
        let M = A.map(row => row.map(val => new Fraction(val.num, val.den)));

        renderStep(M, "Ma tr·∫≠n ban ƒë·∫ßu");

        let pivotRow = 0;
        for (let col = 0; col < n && pivotRow < n; col++) {
            // T√¨m h√†ng c√≥ ph·∫ßn t·ª≠ kh√°c 0 t·∫°i c·ªôt hi·ªán t·∫°i (t·ª´ pivotRow tr·ªü xu·ªëng)
            let sel = -1;
            for (let i = pivotRow; i < n; i++) {
                if (!M[i][col].isZero()) {
                    sel = i;
                    break;
                }
            }

            if (sel === -1) continue; // C·ªôt n√†y to√†n 0, b·ªè qua

            // Ho√°n ƒë·ªïi h√†ng ƒë∆∞a ph·∫ßn t·ª≠ kh√°c 0 l√™n v·ªã tr√≠ pivot
            if (pivotRow !== sel) {
                [M[pivotRow], M[sel]] = [M[sel], M[pivotRow]];
                renderStep(M, `Ho√°n ƒë·ªïi h√†ng ${pivotRow + 1} v√† h√†ng ${sel + 1}.`, pivotRow, col);
            }

            // Kh·ª≠ c√°c h√†ng b√™n d∆∞·ªõi v·ªÅ 0
            for (let i = pivotRow + 1; i < n; i++) {
                let factor = M[i][col].divide(M[pivotRow][col]);
                if (!factor.isZero()) {
                    for (let j = col; j < n; j++) {
                        M[i][j] = M[i][j].subtract(factor.multiply(M[pivotRow][j]));
                    }
                    renderStep(M, `L·∫•y h√†ng ${i + 1} tr·ª´ ƒëi (${factor.toString()}) l·∫ßn h√†ng ${pivotRow + 1}.`, i, col);
                }
            }
            pivotRow++;
        }

        // ƒê·∫øm s·ªë h√†ng kh√°c 0 (Rank)
        let rank = 0;
        for(let i = 0; i < n; i++) {
            if (M[i].some(val => !val.isZero())) {
                rank++;
            }
        }

        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML += `<div class="step-container highlight" style="text-align:center; font-size: 1.2em; color: #7c3aed;">K·∫øt qu·∫£: H·∫°ng c·ªßa ma tr·∫≠n (Rank) = ${rank}</div>`;
        saveToHistory('T√¨m H·∫°ng ma tr·∫≠n', A, null);
    }

    // Kh·ªüi t·∫°o ban ƒë·∫ßu
    // generateInputs(); // Kh√¥ng c·∫ßn g·ªçi ngay, ƒë·ª£i ch·ªçn mode
    document.getElementById('csv-input').addEventListener('change', handleFileImport);

    // --- Laplace Transform Logic ---
    function setupLaplaceUI() {
        const select = document.getElementById('laplace-func-type');
        const isInverse = MODES[currentMode].isInverse;
        select.innerHTML = '';
        
        const options = isInverse ? [
            {val: 'inv_const', text: 'C / s'},
            {val: 'inv_poly', text: 'C / s^n'},
            {val: 'inv_exp', text: '1 / (s - a)'},
            {val: 'inv_sin', text: 'k / (s^2 + k^2)'},
            {val: 'inv_cos', text: 's / (s^2 + k^2)'},
            {val: 'inv_exp_sin', text: 'k / ((s-a)^2 + k^2)'},
            {val: 'inv_exp_cos', text: '(s-a) / ((s-a)^2 + k^2)'}
        ] : [
            {val: 'const', text: 'H·∫±ng s·ªë (C)'},
            {val: 'poly', text: 'ƒêa th·ª©c (t^n)'},
            {val: 'exp', text: 'M≈© (e^at)'},
            {val: 'sin', text: 'Sin (sin kt)'},
            {val: 'cos', text: 'Cos (cos kt)'},
            {val: 'exp_sin', text: 'e^at * sin(kt)'},
            {val: 'exp_cos', text: 'e^at * cos(kt)'}
        ];

        options.forEach(opt => {
            const el = document.createElement('option');
            el.value = opt.val;
            el.innerText = opt.text;
            select.appendChild(el);
        });
        
        const label = document.getElementById('laplace-label');
        const btn = document.getElementById('laplace-btn');
        label.innerText = isInverse ? "Ch·ªçn h√†m F(s): " : "Ch·ªçn h√†m f(t): ";
        btn.innerText = isInverse ? "Bi·∫øn ƒë·ªïi ng∆∞·ª£c sang f(t)" : "Bi·∫øn ƒë·ªïi sang F(s)";
        btn.onclick = isInverse ? calculateInverseLaplaceTransform : calculateLaplaceTransform;
        
        updateLaplaceInputs();
    }

    function updateLaplaceInputs() {
        const type = document.getElementById('laplace-func-type').value;
        const container = document.getElementById('laplace-inputs');
        container.innerHTML = '';

        const addInput = (id, label, defaultVal = 1) => {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = `<label style="margin-right:5px; font-weight:bold;">${label} = </label>`;
            const input = document.createElement('input');
            input.type = 'number';
            input.id = id;
            input.value = defaultVal;
            input.style.width = '70px';
            input.style.padding = '8px';
            input.style.borderRadius = '6px';
            input.style.border = '1px solid var(--border-color)';
            input.style.background = 'var(--input-bg)';
            input.style.color = 'var(--text-main)';
            input.style.textAlign = 'center';
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        };

        if (type === 'const') addInput('lp-c', 'C', 5);
        if (type === 'poly') addInput('lp-n', 'n', 2);
        if (type === 'exp' || type === 'exp_sin' || type === 'exp_cos') addInput('lp-a', 'a', 2);
        if (type === 'sin' || type === 'cos' || type === 'exp_sin' || type === 'exp_cos') addInput('lp-k', 'k', 3);
        
        // Inverse inputs
        if (type === 'inv_const') addInput('lp-c', 'C', 1);
        if (type === 'inv_poly') { addInput('lp-c', 'C', 1); addInput('lp-n', 'n', 2); }
        if (type === 'inv_exp' || type === 'inv_exp_sin' || type === 'inv_exp_cos') addInput('lp-a', 'a', 2);
        if (type === 'inv_sin' || type === 'inv_cos' || type === 'inv_exp_sin' || type === 'inv_exp_cos') addInput('lp-k', 'k', 3);
    }

    function renderLaplaceTheory() {
        const isInverse = MODES[currentMode].isInverse;
        const stepsDiv = document.getElementById('solution-steps');
        stepsDiv.innerHTML = `
            <div class="step-container">
                <div class="step-description">B·∫£ng c√¥ng th·ª©c Laplace ${isInverse ? 'Ng∆∞·ª£c' : ''} c∆° b·∫£n</div>
                <table style="width:100%; border-collapse: collapse; margin-top:10px;">
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <th style="padding:10px; text-align:left;">${isInverse ? 'H√†m ·∫£nh F(s)' : 'H√†m g·ªëc f(t)'}</th>
                        <th style="padding:10px; text-align:left;">${isInverse ? 'H√†m g·ªëc f(t)' : 'Bi·∫øn ƒë·ªïi F(s)'}</th>
                    </tr>
                    ${isInverse ? `
                    <tr><td style="padding:8px;">1/s</td><td style="padding:8px;">1</td></tr>
                    <tr><td style="padding:8px;">1/s^n</td><td style="padding:8px;">t^(n-1) / (n-1)!</td></tr>
                    <tr><td style="padding:8px;">1/(s-a)</td><td style="padding:8px;">e^(at)</td></tr>
                    <tr><td style="padding:8px;">k/(s^2+k^2)</td><td style="padding:8px;">sin(kt)</td></tr>
                    <tr><td style="padding:8px;">s/(s^2+k^2)</td><td style="padding:8px;">cos(kt)</td></tr>
                    ` : `
                    <tr><td style="padding:8px;">1</td><td style="padding:8px;">1/s</td></tr>
                    <tr><td style="padding:8px;">t^n</td><td style="padding:8px;">n! / s^(n+1)</td></tr>
                    <tr><td style="padding:8px;">e^(at)</td><td style="padding:8px;">1 / (s - a)</td></tr>
                    <tr><td style="padding:8px;">sin(kt)</td><td style="padding:8px;">k / (s^2 + k^2)</td></tr>
                    <tr><td style="padding:8px;">cos(kt)</td><td style="padding:8px;">s / (s^2 + k^2)</td></tr>
                    `}
                </table>
            </div>
        `;
    }

    function calculateLaplaceTransform() {
        const type = document.getElementById('laplace-func-type').value;
        const stepsDiv = document.getElementById('solution-steps');
        
        renderLaplaceTheory();

        let result = '';
        let formula = '';
        let inputDesc = '';

        const getVal = (id) => parseFloat(document.getElementById(id).value);

        if (type === 'const') {
            const c = getVal('lp-c');
            inputDesc = `f(t) = ${c}`;
            formula = `L{C} = C/s`;
            result = `${c}/s`;
        } else if (type === 'poly') {
            const n = getVal('lp-n');
            if (n < 0 || !Number.isInteger(n)) { alert('n ph·∫£i l√† s·ªë nguy√™n d∆∞∆°ng'); return; }
            inputDesc = `f(t) = t^${n}`;
            let fact = 1; for(let i=2; i<=n; i++) fact *= i;
            formula = `L{t^n} = n! / s^(n+1)`;
            result = `${fact} / s^${n+1}`;
        } else if (type === 'exp') {
            const a = getVal('lp-a');
            inputDesc = `f(t) = e^(${a}t)`;
            formula = `L{e^at} = 1 / (s - a)`;
            const sign = a >= 0 ? '-' : '+';
            result = `1 / (s ${sign} ${Math.abs(a)})`;
        } else if (type === 'sin') {
            const k = getVal('lp-k');
            inputDesc = `f(t) = sin(${k}t)`;
            formula = `L{sin(kt)} = k / (s^2 + k^2)`;
            result = `${k} / (s^2 + ${k*k})`;
        } else if (type === 'cos') {
            const k = getVal('lp-k');
            inputDesc = `f(t) = cos(${k}t)`;
            formula = `L{cos(kt)} = s / (s^2 + k^2)`;
            result = `s / (s^2 + ${k*k})`;
        } else if (type === 'exp_sin') {
            const a = getVal('lp-a');
            const k = getVal('lp-k');
            inputDesc = `f(t) = e^(${a}t)sin(${k}t)`;
            formula = `L{e^at sin(kt)} = k / ((s-a)^2 + k^2)`;
            const sign = a >= 0 ? '-' : '+';
            result = `${k} / ((s ${sign} ${Math.abs(a)})^2 + ${k*k})`;
        } else if (type === 'exp_cos') {
            const a = getVal('lp-a');
            const k = getVal('lp-k');
            inputDesc = `f(t) = e^(${a}t)cos(${k}t)`;
            formula = `L{e^at cos(kt)} = (s-a) / ((s-a)^2 + k^2)`;
            const sign = a >= 0 ? '-' : '+';
            result = `(s ${sign} ${Math.abs(a)}) / ((s ${sign} ${Math.abs(a)})^2 + ${k*k})`;
        }

        const resultHtml = `
            <div class="step-container highlight" style="border-left-color: #f59e0b;">
                <div class="step-description">K·∫øt qu·∫£ bi·∫øn ƒë·ªïi:</div>
                <div style="font-size: 1.2em; margin-bottom: 10px;">${inputDesc}</div>
                <div style="margin-bottom: 10px; color: var(--text-muted);">√Åp d·ª•ng c√¥ng th·ª©c: ${formula}</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #d97706;">F(s) = ${result}</div>
            </div>
        `;
        stepsDiv.insertAdjacentHTML('afterbegin', resultHtml);
    }

    function calculateInverseLaplaceTransform() {
        const type = document.getElementById('laplace-func-type').value;
        const stepsDiv = document.getElementById('solution-steps');
        renderLaplaceTheory();

        let result = '';
        let formula = '';
        let inputDesc = '';
        const getVal = (id) => parseFloat(document.getElementById(id).value);

        if (type === 'inv_const') {
            const c = getVal('lp-c');
            inputDesc = `F(s) = ${c}/s`;
            formula = `L‚Åª¬π{C/s} = C`;
            result = `${c}`;
        } else if (type === 'inv_poly') {
            const c = getVal('lp-c');
            const n = getVal('lp-n');
            if (n <= 0 || !Number.isInteger(n)) { alert('n ph·∫£i l√† s·ªë nguy√™n d∆∞∆°ng'); return; }
            inputDesc = `F(s) = ${c}/s^${n}`;
            formula = `L‚Åª¬π{1/s^n} = t^(n-1) / (n-1)!`;
            let fact = 1; for(let i=2; i<n; i++) fact *= i; // (n-1)!
            result = `${c}/${fact} * t^${n-1}`;
            if (c % fact === 0) result = `${c/fact}t^${n-1}`;
        } else if (type === 'inv_exp') {
            const a = getVal('lp-a');
            const sign = a >= 0 ? '-' : '+';
            inputDesc = `F(s) = 1 / (s ${sign} ${Math.abs(a)})`;
            formula = `L‚Åª¬π{1/(s-a)} = e^(at)`;
            result = `e^(${a}t)`;
        } else if (type === 'inv_sin') {
            const k = getVal('lp-k');
            inputDesc = `F(s) = ${k} / (s^2 + ${k*k})`;
            formula = `L‚Åª¬π{k/(s^2+k^2)} = sin(kt)`;
            result = `sin(${k}t)`;
        } else if (type === 'inv_cos') {
            const k = getVal('lp-k');
            inputDesc = `F(s) = s / (s^2 + ${k*k})`;
            formula = `L‚Åª¬π{s/(s^2+k^2)} = cos(kt)`;
            result = `cos(${k}t)`;
        } else if (type === 'inv_exp_sin') {
            const a = getVal('lp-a');
            const k = getVal('lp-k');
            const sign = a >= 0 ? '-' : '+';
            inputDesc = `F(s) = ${k} / ((s ${sign} ${Math.abs(a)})^2 + ${k*k})`;
            formula = `L‚Åª¬π{k/((s-a)^2+k^2)} = e^(at)sin(kt)`;
            result = `e^(${a}t)sin(${k}t)`;
        } else if (type === 'inv_exp_cos') {
            const a = getVal('lp-a');
            const k = getVal('lp-k');
            const sign = a >= 0 ? '-' : '+';
            inputDesc = `F(s) = (s ${sign} ${Math.abs(a)}) / ((s ${sign} ${Math.abs(a)})^2 + ${k*k})`;
            formula = `L‚Åª¬π{(s-a)/((s-a)^2+k^2)} = e^(at)cos(kt)`;
            result = `e^(${a}t)cos(${k}t)`;
        }

        const resultHtml = `
            <div class="step-container highlight" style="border-left-color: #d97706;">
                <div class="step-description">K·∫øt qu·∫£ bi·∫øn ƒë·ªïi ng∆∞·ª£c:</div>
                <div style="font-size: 1.2em; margin-bottom: 10px;">${inputDesc}</div>
                <div style="margin-bottom: 10px; color: var(--text-muted);">√Åp d·ª•ng c√¥ng th·ª©c: ${formula}</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #d97706;">f(t) = ${result}</div>
            </div>
        `;
        stepsDiv.insertAdjacentHTML('afterbegin', resultHtml);
    }

    // --- L·ªãch s·ª≠ (LocalStorage) ---
    const HISTORY_KEY = 'matrixSolverHistory';
    const MAX_HISTORY_ITEMS = 20;

    function saveToHistory(type, matrixA, vectorB) {
        const solutionHtml = document.getElementById('solution-steps').innerHTML;
        if (!solutionHtml || solutionHtml.trim() === '') return;

        let history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];

        const newEntry = {
            id: Date.now(),
            type: type,
            matrixA: matrixA,
            vectorB: vectorB,
            solution: solutionHtml,
            timestamp: new Date().toISOString()
        };

        history.unshift(newEntry);
        if (history.length > MAX_HISTORY_ITEMS) history = history.slice(0, MAX_HISTORY_ITEMS);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    }

    function openHistoryModal() {
        renderHistory();
        document.getElementById('history-modal').style.display = 'flex';
    }

    function closeHistoryModal() {
        document.getElementById('history-modal').style.display = 'none';
    }

    function renderHistory() {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        const list = document.getElementById('history-list');
        list.innerHTML = history.length === 0 ? '<li>Ch∆∞a c√≥ b√†i to√°n n√†o ƒë∆∞·ª£c gi·∫£i.</li>' : history.map(item => {
            const time = new Date(item.timestamp);
            const size = item.matrixA.length;
            return `<li>
                <div class="history-info">
                    <div class="history-type">${item.type} (${size}x${size})</div>
                    <div class="history-time">${time.toLocaleString('vi-VN')}</div>
                </div>
                <div class="history-actions">
                    <button onclick="loadFromHistory(${item.id})">Xem l·∫°i</button>
                    <button onclick="deleteFromHistory(${item.id})" style="background: #ef4444">X√≥a</button>
                </div>
            </li>`;
        }).join('');
    }

    function loadFromHistory(id) {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        const item = history.find(h => h.id === id);
        if (!item) return;
        document.getElementById('size').value = item.matrixA.length;
        generateInputs();
        for (let i = 0; i < item.matrixA.length; i++) {
            for (let j = 0; j < item.matrixA.length; j++) document.getElementById(`m-${i}-${j}`).value = new Fraction(item.matrixA[i][j].num, item.matrixA[i][j].den).toString();
            if (item.vectorB && item.vectorB[i]) document.getElementById(`b-${i}`).value = new Fraction(item.vectorB[i].num, item.vectorB[i].den).toString();
        }
        document.getElementById('solution-steps').innerHTML = item.solution;
        closeHistoryModal();
    }

    function clearAllHistory() {
        if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠?')) {
            localStorage.removeItem(HISTORY_KEY);
            renderHistory();
        }
    }

    function deleteFromHistory(id) {
        let history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        history = history.filter(h => h.id !== id);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        renderHistory();
    }
    
    window.addEventListener('resize', () => {
        const plotDiv = document.getElementById('geo-plot');
        if (plotDiv) {
            Plotly.Plots.resize(plotDiv);
        }
    });
</script>

</body>
</html>

           

